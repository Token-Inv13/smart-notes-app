'use client';

import { getToken, onMessage } from 'firebase/messaging';
import { doc, getDoc, serverTimestamp, setDoc, updateDoc } from 'firebase/firestore';
import { getMessagingInstance } from './firebase';
import { auth, db } from './firebase';

function toTasksQueryUrl(raw?: string | null, taskIdFallback?: string | null): string | undefined {
  const fallback =
    typeof taskIdFallback === 'string' && taskIdFallback
      ? `/tasks?taskId=${encodeURIComponent(taskIdFallback)}`
      : undefined;

  if (!raw) return fallback;

  const absolute = raw.startsWith('http://') || raw.startsWith('https://');
  if (absolute) return raw;

  if (raw.startsWith('/tasks?')) return raw;

  const taskPathMatch = raw.match(/^\/tasks\/([^/?#]+)/);
  if (taskPathMatch?.[1]) {
    return `/tasks?taskId=${encodeURIComponent(taskPathMatch[1])}`;
  }

  return raw || fallback;
}

async function withTimeout<T>(promise: Promise<T>, timeoutMs: number, label: string): Promise<T> {
  let timeoutId: ReturnType<typeof setTimeout> | undefined;
  const timeoutPromise = new Promise<T>((_, reject) => {
    timeoutId = setTimeout(() => {
      reject(new Error(`${label} timed out after ${timeoutMs}ms`));
    }, timeoutMs);
  });

  try {
    return await Promise.race([promise, timeoutPromise]);
  } finally {
    if (timeoutId) clearTimeout(timeoutId);
  }
}

async function waitForServiceWorkerActivation(
  registration: ServiceWorkerRegistration,
  timeoutMs = 5000,
): Promise<ServiceWorkerRegistration> {
  const sw = registration.active ?? registration.waiting ?? registration.installing;
  if (!sw) return registration;
  if (sw.state === 'activated') return registration;

  await withTimeout(
    new Promise<void>((resolve) => {
      const onStateChange = () => {
        if (sw.state === 'activated') {
          sw.removeEventListener('statechange', onStateChange);
          resolve();
        }
      };
      sw.addEventListener('statechange', onStateChange);
    }),
    timeoutMs,
    'service worker activation',
  );

  return registration;
}

export async function requestNotificationPermission(): Promise<NotificationPermission> {
  if (typeof window === 'undefined' || !('Notification' in window)) {
    return 'denied';
  }

  if (Notification.permission === 'granted') {
    return 'granted';
  }

  if (Notification.permission === 'denied') {
    return 'denied';
  }

  try {
    // Some browsers can keep the permission promise pending if the prompt is blocked/hidden.
    const next = await withTimeout(
      Promise.resolve(Notification.requestPermission()),
      15000,
      'Notification.requestPermission',
    );
    return next;
  } catch (e) {
    console.warn('Notification permission request did not resolve in time', e);
    // Keep "default" so the UI can ask the user to retry.
    return 'default';
  }
}

export async function getFcmToken(): Promise<string | null> {
  const permission = await requestNotificationPermission();
  if (permission !== 'granted') {
    return null;
  }

  const messaging = await getMessagingInstance();
  if (!messaging) {
    return null;
  }

  const vapidKey = process.env.NEXT_PUBLIC_FCM_VAPID_KEY;
  if (!vapidKey) {
    console.warn('NEXT_PUBLIC_FCM_VAPID_KEY is not set');
    return null;
  }

  let serviceWorkerRegistration: ServiceWorkerRegistration | undefined;
  if (typeof window !== 'undefined' && 'serviceWorker' in navigator) {
    try {
      // Use the PWA service worker generated by next-pwa (/sw.js).
      // This avoids relying on a dynamically served messaging SW and reduces scope/registration issues.
      serviceWorkerRegistration = await navigator.serviceWorker.register('/sw.js', { scope: '/' });
      serviceWorkerRegistration = await waitForServiceWorkerActivation(serviceWorkerRegistration, 5000);
    } catch (e) {
      console.warn(
        'Service worker is not ready (or timed out); trying to proceed without explicit SW registration.',
        e,
      );

      try {
        serviceWorkerRegistration = (await navigator.serviceWorker.getRegistration('/')) ?? undefined;
      } catch (err) {
        console.warn('Failed to get service worker registration', err);
      }
    }
  } else {
    console.warn('Service workers are not supported in this environment; push notifications will not work.');
  }

  try {
    const token = await withTimeout(
      getToken(messaging, { vapidKey, serviceWorkerRegistration }),
      15000,
      'firebase.messaging.getToken',
    );
    return token || null;
  } catch (error) {
    console.error('Error retrieving FCM token', error);
    return null;
  }
}

export function listenToForegroundMessages() {
  if (typeof window === 'undefined') return;

  getMessagingInstance().then((messaging) => {
    if (!messaging) return;

    onMessage(messaging, (payload) => {
      const title = payload.notification?.title || 'Notification';
      const body = payload.notification?.body || '';
      const data = payload.data as { url?: string; taskId?: string } | undefined;
      const url = toTasksQueryUrl(data?.url, data?.taskId);

      if (typeof Notification === 'undefined') {
        console.log('Received foreground message', payload);
        return;
      }

      if (Notification.permission !== 'granted') {
        console.log('Received foreground message (no permission)', payload);
        return;
      }

      try {
        const n = new Notification(title, {
          body,
          data: { url },
        });

        n.onclick = () => {
          try {
            if (url) {
              window.open(url, '_blank', 'noopener,noreferrer');
            }
          } catch {
            // ignore
          }
        };
      } catch (e) {
        console.log('Received foreground message (notification failed)', payload, e);
      }
    });
  });
}

export async function registerFcmToken() {
  const user = auth.currentUser;
  if (!user) {
    console.warn('User not authenticated, skipping FCM token registration');
    return;
  }

  const token = await getFcmToken();
  if (!token) {
    console.warn('No FCM token retrieved');
    return;
  }

  try {
    const userRef = doc(db, 'users', user.uid);
    const snap = await getDoc(userRef);

    if (!snap.exists()) {
      await setDoc(userRef, {
        uid: user.uid,
        email: user.email ?? null,
        fcmTokens: { [token]: true },
        settings: { notifications: { taskReminders: true } },
        updatedAt: serverTimestamp(),
      }, { merge: true });
      console.log(`Registered FCM token for new user document ${user.uid}`);
      return;
    }

    const data = snap.data() as { fcmTokens?: Record<string, boolean> };
    const existingTokens = data.fcmTokens ?? {};

    if (existingTokens[token]) {
      await updateDoc(userRef, {
        'settings.notifications.taskReminders': true,
        updatedAt: serverTimestamp(),
      });
      console.log('FCM token already registered for this user; reminders enabled');
      return;
    }

    // Avoid using the raw token in a field path (tokens can contain '.', ':', etc.).
    // Instead, update the whole map.
    await updateDoc(userRef, {
      fcmTokens: { ...existingTokens, [token]: true },
      'settings.notifications.taskReminders': true,
      updatedAt: serverTimestamp(),
    });

    console.log(`Registered FCM token for user ${user.uid}`);
  } catch (error) {
    console.error('Error registering FCM token in Firestore', error);
  }
}
